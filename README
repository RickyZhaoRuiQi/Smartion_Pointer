1：什么是智能指针？

智能指针(smart pointer)是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露（利用自动调用类
的析构函数来释放内存）。它的一种通用实现技术是使用引用计数（除此之外还有资源独占，如(auto_ptr),只引用，不计数(weak_ptr))。智能指针类将一个
计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副
本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，
则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，析构函数减少引用计数（如果引用计数减至0，则删除基础对象）。

2：为什么要用智能指针以及智能指针的原理是什么？

原因：1）：手动malloc/new出来的资源，容易忘记free/delete；
      2）：影响执行流的地方需要注意释放释放资源，容易导致资源泄漏（如free/delete在return之后）。
      3）：中途抛出异常，无法释放资源。如：int*p1=new int；int*p2=new int [10000000]；delete p1;delele [ ] p2;因为p2 new的内存比较大，万一new失
      败，则导致p1永远无法释放。

原理：为了解决以（1）、（2）、（3）上问题，创建一份资源出来的时候，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。除此之外，
通过运算符重载（重载*和重载->等），可以像指针一样使用。

3：分析下常见的智能指针有哪些？

（1）：auto_ptr
	1）它是C++标准库提供的类模板，auto_ptr对象通过初始化指向由new创建的动态内存，它是这块内存的拥有者，一块内存不能同时被分给两个拥有者（资源独占
	）。当auto_ptr对象生命周期结束时，其析构函数会将auto_ptr对象拥有的动态内存自动释放。
	2）auto_ptr不能指向数组，因为auto_ptr在析构的时候只是调用delete,而数组应该要调用delete[]。（但uniquearray管理的是一段连续的空间，它也是防拷
	贝的，功能类似于vector。）
	3）auto_ptr不能作为容器对象，因为它不支持拷贝构造与赋值（出错了也不容易发现），STL容器中的元素经常要支持拷贝，赋值等操作，在这过程中auto_ptr
	会传递所有权，那么就会出错。

（2）：unique_ptr
	它是（ C++11引入的，前身是scoped_ptr，scoped_ptr是boost库里的），也不支持拷贝构造和赋值，但比auto_ptr好，直接赋值会编译出错（与auto_ptr最
	大的不同就是类内私有的声明了拷贝构造函数和赋值运算符重载，是针对auto_ptr的缺点而出现的）。

（3）：shared_ptr
 	C++11或boost的shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。环状的链式结构可能会形成内存泄露
	（循环引用）
 
为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。

（4）：weak_ptr
	C++11或boost的weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。
	顾名思义，weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就
	是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释
	放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。weak_ptr并没有重载operator->和operator *操作符，因
	此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象。

